{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/index.js","webpack:///./node_modules/sha256/lib/nodecrypto.js","webpack:///external \"crypto\""],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","hasher","Blocktron","_classCallCheck","this","chain","pendingTransactions","createNewBlock","nonce","previousHash","hash","Error","newBlock","index","length","timeStamp","Date","now","transactions","push","amount","sender","reciever","newTransactions","getLastBlock","previousBlockHash","currentBlockData","toString","JSON","stringify","hashString","hashBlock","substring","crypto","sha256","message","options","createHash","Buffer","isBuffer","update","Array","isArray","buf","digest","asBytes","a","asString","x2","require"],"mappings":"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","file":"main.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/**\r\n * blocktron-lib\r\n * This file contains the Blocktron Class which houses the core blockchain functions and methods\r\n * Written by: Sandeep Vattapparambil\r\n * Email: sandeepv68@gmail.com\r\n * Website: www.sandeepv.in\r\n */\r\n\r\n/**\r\n * Blocktron Module\r\n * @module Blocktron\r\n */\r\n\r\n/**\r\n * ECMAScript 5's strict mode is a way to opt in to a restricted variant of JavaScript,\r\n * thereby implicitly opting-out of \"sloppy mode\". Strict mode isn't just a subset:\r\n * it intentionally has different semantics from normal code. Browsers not supporting\r\n * strict mode will run strict mode code with different behavior from browsers that do,\r\n * so don't rely on strict mode without feature-testing for support for the relevant\r\n * aspects of strict mode. Strict mode code and non-strict mode code can coexist,\r\n * so scripts can opt into strict mode incrementally.\r\n * Strict mode makes several changes to normal JavaScript semantics:\r\n *  1. Eliminates some JavaScript silent errors by changing them to throw errors.\r\n *  2. Fixes mistakes that make it difficult for JavaScript engines to perform optimizations:\r\n *     strict mode code can sometimes be made to run faster than identical code that's not strict mode.\r\n *  3. Prohibits some syntax likely to be defined in future versions of ECMAScript.\r\n */\r\n\"use strict\";\r\n\r\n/**\r\n * A JavaScript component to compute the SHA256 of strings or bytes.\r\n * Note: when Node.js is detected, the Node Crypto component is used\r\n * instead of re-implementing the SHA256 hash logic.\r\n * @see {@link https://www.npmjs.com/package/sha256|NPM sha256}\r\n * @see {@link https://en.wikipedia.org/wiki/SHA-2|SHA-2}\r\n */\r\nconst hasher = require(\"sha256\");\r\n\r\n/**\r\n * The main Blocktron Class.\r\n * @class Blocktron\r\n */\r\nclass Blocktron {\r\n   /**\r\n    * The Blocktron Class properties constructor\r\n    */\r\n   constructor() {\r\n      this.chain = [];\r\n      this.pendingTransactions = [];\r\n      /**\r\n       * Genesis block defaults\r\n       * A genesis block is the first block of a block chain. Modern versions of Bitcoin number\r\n       * it as block 0, though very early versions counted it as block 1. The genesis block is\r\n       * almost always hardcoded into the software of the applications that utilize its block\r\n       * chain. It is a special case in that it does not reference a previous block, and for Bitcoin\r\n       * and almost all of its derivatives, it produces an unspendable subsidy.\r\n       * @see {@link https://en.bitcoin.it/wiki/Genesis_block|Bitcoin Wiki}\r\n       */\r\n      this.createNewBlock(1, \"0\", \"0\");\r\n   }\r\n\r\n   /**\r\n    * Blocktron methods\r\n    */\r\n\r\n   /**\r\n    * @function createNewBlock\r\n    * Blocktron method to create a new block on to the blockchain\r\n    * @param {String} nonce - The nonce obtained from proof-of-work\r\n    * @param {String} previousHash - The hash of the previous block\r\n    * @param {String} hash - The hash generated from this block's data\r\n    * @returns {Object} - Returns the new block object\r\n    */\r\n   createNewBlock(nonce, previousHash, hash) {\r\n      /**\r\n       * Validate the parameters\r\n       */\r\n      nonce = nonce\r\n         ? nonce\r\n         : (function() {\r\n              throw new Error(\"Nonce required\");\r\n           })();\r\n      previousHash = previousHash\r\n         ? previousHash\r\n         : (function() {\r\n              throw new Error(\"Previous hash required\");\r\n           })();\r\n      hash = hash\r\n         ? hash\r\n         : (function() {\r\n              throw new Error(\"Hash required\");\r\n           })();\r\n\r\n      /**\r\n       * @type {Object}\r\n       * @const newBlock - An atomic block in the chain\r\n       * @property {Number} index - The chronological position of this block in the chain\r\n       * @property {String} timeStamp - The time of creation of the block\r\n       * @property {String} transactions - The value of transaction to be recorded\r\n       * @property {String} nonce - The nonce obtained from proof-of-work\r\n       * @property {String} hash - The hash generated from this block's data\r\n       * @property {String} previousHash - The hash of the previous block\r\n       */\r\n      const newBlock = {\r\n         index: this.chain.length + 1,\r\n         timeStamp: Date.now(),\r\n         transactions: this.pendingTransactions,\r\n         nonce: nonce,\r\n         hash: hash,\r\n         previousHash: previousHash\r\n      };\r\n\r\n      /**\r\n       * Reset the pendingTransactions array back to empty after creating the new block,\r\n       * so that the createNewBlock method can start over again from zero.\r\n       */\r\n      this.pendingTransactions = [];\r\n\r\n      /**\r\n       * Then push the new block to the chain\r\n       */\r\n      this.chain.push(newBlock);\r\n\r\n      /**\r\n       * Returns the newly created block\r\n       */\r\n      return newBlock;\r\n   }\r\n\r\n   /**\r\n    * @function getLastBlock\r\n    * A method to retreive the penultimate block with respect to current block\r\n    * @returns {Object} - Returns the block object\r\n    */\r\n   getLastBlock() {\r\n      /**\r\n       * This method simply returns the block object from the data\r\n       * structure at the penultimate position\r\n       */\r\n      return this.chain[this.chain.length - 1];\r\n   }\r\n\r\n   /**\r\n    * @function createNewTransaction\r\n    * A method to create a new transaction\r\n    * @param {Number} amount - The amount/value to be recorded\r\n    * @param {String} sender - The adress of the sender\r\n    * @param {String} reciever - The address of the reciever\r\n    * @returns {Object} - Returns the transaction object\r\n    */\r\n   createNewTransaction(amount, sender, reciever) {\r\n      /**\r\n       * Validate the parameters\r\n       */\r\n      amount = amount\r\n         ? amount\r\n         : (function() {\r\n              throw new Error(\"Amount required\");\r\n           })();\r\n      sender = sender\r\n         ? sender\r\n         : (function() {\r\n              throw new Error(\"Sender required\");\r\n           })();\r\n      reciever = reciever\r\n         ? reciever\r\n         : (function() {\r\n              throw new Error(\"Reciever required\");\r\n           })();\r\n\r\n      /**\r\n       * @type {Object}\r\n       * @const newTransactions - An atomic transactions block in the chain\r\n       * @property {Number} amount - The value/amount to be recorded\r\n       * @property {String} sender - The adress of the sender\r\n       * @property {String} reciever - The address of the reciever\r\n       */\r\n      const newTransactions = {\r\n         amount: amount,\r\n         sender: sender,\r\n         reciever: reciever\r\n      };\r\n\r\n      /**\r\n       * Push the new transaction to the chain\r\n       */\r\n      this.pendingTransactions.push(newTransactions);\r\n\r\n      /**\r\n       * Returns the number of the block, this transaction will be added to\r\n       */\r\n      return this.getLastBlock()[\"index\"] + 1;\r\n   }\r\n\r\n   /**\r\n    * @function hashBlock\r\n    * A helper method to generate a hash string out of a blocks data\r\n    * @param {String} previousBlockHash - The hash of the previous block\r\n    * @param {Object} currentBlockData - The current block's data\r\n    * @param {Number} nonce - The nonce of the block\r\n    * @returns {String} - The hash string generated out of the block data\r\n    */\r\n   hashBlock(previousBlockHash, currentBlockData, nonce) {\r\n      /**\r\n       * Validate the parameters\r\n       */\r\n      previousBlockHash = previousBlockHash\r\n         ? previousBlockHash\r\n         : (function() {\r\n              throw new Error(\"Previous block hash required\");\r\n           })();\r\n      currentBlockData = currentBlockData\r\n         ? currentBlockData\r\n         : (function() {\r\n              throw new Error(\"Current block data required\");\r\n           })();\r\n      nonce = nonce ? nonce : \"\";\r\n      return hasher(\r\n         previousBlockHash + nonce.toString() + JSON.stringify(currentBlockData)\r\n      );\r\n   }\r\n\r\n   /**\r\n    * @function proofOfWork\r\n    * An opinionated, standardized, and universally approved blockchain method\r\n    * to validate random blocks added to the blockchain.\r\n    * Process:\r\n    * 1. Repeatedly hash the block data until it reaches the format: '0000<HF98WDYS89DCSD>'.\r\n    * 2. Uses current block data as well as previous block hash.\r\n    * 3. Continuously change the nonce until the correct hash is obtained.\r\n    * 4. Return the nonce value which generates the correct hash.\r\n    * The entire proofOfWork calculation runs to a time complexity of O(n).\r\n    * @see {@link https://keepingstock.net/explaining-blockchain-how-proof-of-work-enables-trustless-consensus-2abed27f0845| Explaining blockchain}\r\n    * @param {String} previousBlockHash - The hash of the previous block\r\n    * @param {Object} currentBlockData - The current block's data\r\n    * @returns {Number} - Returns the valid nonce number\r\n    */\r\n   proofOfWork(previousBlockHash, currentBlockData) {\r\n      /**\r\n       * Use block scoping rather than constants, because there is a guarenteed rebinding of data to objects.\r\n       */\r\n      let nonce = 0;\r\n      let hashString = this.hashBlock(previousBlockHash, currentBlockData, nonce);\r\n\r\n      /**\r\n       * While-loop is prefered over for-loop or other looping constructs.\r\n       * The loop exit point is unknown in this case.\r\n       * @see {@link https://stackoverflow.com/questions/39969145/while-loops-vs-for-loops-in-javascript|While Loops vs. For Loops in JavaScript?}\r\n       */\r\n      while (hashString.substring(0, 4) !== \"0000\") {\r\n         nonce++;\r\n         hashString = this.hashBlock(previousBlockHash, currentBlockData, nonce);\r\n      }\r\n\r\n      /**\r\n       * Simple returns the nonce value which can generate the correct\r\n       * hash string of pre-determined format, thus the proof.\r\n       */\r\n      return nonce;\r\n   }\r\n}\r\n\r\nmodule.exports = Blocktron;\r\n","var crypto = require('crypto');\n\n// Node.js has its own Crypto function that can handle this natively\nvar sha256 = module.exports = function(message, options) {\n\tvar c = crypto.createHash('sha256');\n\t\n\tif (Buffer.isBuffer(message)) {\n\t\tc.update(message);\n\t} else if (Array.isArray(message)) {\n\t\t// Array of byte values\n\t\tc.update(new Buffer(message));\n\t} else {\n\t\t// Otherwise, treat as a binary string\n\t\tc.update(new Buffer(message, 'binary'));\n\t}\n\tvar buf = c.digest();\n\t\n\tif (options && options.asBytes) {\n\t\t// Array of bytes as decimal integers\n\t\tvar a = [];\n\t\tfor(var i = 0; i < buf.length; i++) {\n\t\t\ta.push(buf[i]);\n\t\t}\n\t\treturn a;\n\t} else if (options && options.asString) {\n\t\t// Binary string\n\t\treturn buf.toString('binary');\n\t} else {\n\t\t// String of hex characters\n\t\treturn buf.toString('hex');\n\t}\n}\n\nsha256.x2 = function(message, options) {\n\treturn sha256(sha256(message, { asBytes:true }), options)\n}\n","module.exports = require(\"crypto\");"],"sourceRoot":""}