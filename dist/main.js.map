{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/index.js","webpack:///./node_modules/sha256/lib/nodecrypto.js","webpack:///external \"crypto\""],"names":["hasher","require","Blocktron","chain","pendingTransactions","createNewBlock","nonce","previousHash","hash","Error","newBlock","index","length","timeStamp","Date","now","transactions","push","amount","sender","receiver","newTransactions","getLastBlock","previousBlockHash","currentBlockData","toString","JSON","stringify","hashString","hashBlock","substring","module","exports"],"mappings":"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","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/**\r\n * blocktron-lib\r\n * This file contains the Blocktron Class which houses the core blockchain functions and methods\r\n * Written by: Sandeep Vattapparambil\r\n * Email: sandeepv68@gmail.com\r\n * Website: www.sandeepv.in\r\n */\r\n\r\n/**\r\n * Blocktron Module\r\n * @module Blocktron\r\n */\r\n\r\n/**\r\n * ECMAScript 5's strict mode is a way to opt in to a restricted variant of JavaScript,\r\n * thereby implicitly opting-out of \"sloppy mode\". Strict mode isn't just a subset:\r\n * it intentionally has different semantics from normal code. Browsers not supporting\r\n * strict mode will run strict mode code with different behavior from browsers that do,\r\n * so don't rely on strict mode without feature-testing for support for the relevant\r\n * aspects of strict mode. Strict mode code and non-strict mode code can coexist,\r\n * so scripts can opt into strict mode incrementally.\r\n * Strict mode makes several changes to normal JavaScript semantics:\r\n *  1. Eliminates some JavaScript silent errors by changing them to throw errors.\r\n *  2. Fixes mistakes that make it difficult for JavaScript engines to perform optimizations:\r\n *     strict mode code can sometimes be made to run faster than identical code that's not strict mode.\r\n *  3. Prohibits some syntax likely to be defined in future versions of ECMAScript.\r\n */\r\n'use strict';\r\n\r\n/**\r\n * A JavaScript component to compute the SHA256 of strings or bytes.\r\n * Note: when Node.js is detected, the Node Crypto component is used\r\n * instead of re-implementing the SHA256 hash logic.\r\n * @see {@link https://www.npmjs.com/package/sha256|NPM sha256}\r\n * @see {@link https://en.wikipedia.org/wiki/SHA-2|SHA-2}\r\n */\r\nconst hasher = require('sha256');\r\n\r\n/**\r\n * The main Blocktron Class.\r\n * @class Blocktron\r\n */\r\nclass Blocktron {\r\n   /**\r\n    * The Blocktron Class properties constructor\r\n    */\r\n   constructor() {\r\n      this.chain = [];\r\n      this.pendingTransactions = [];\r\n      /**\r\n       * Genesis block defaults\r\n       * A genesis block is the first block of a block chain. Modern versions of Bitcoin number\r\n       * it as block 0, though very early versions counted it as block 1. The genesis block is\r\n       * almost always hardcoded into the software of the applications that utilize its block\r\n       * chain. It is a special case in that it does not reference a previous block, and for Bitcoin\r\n       * and almost all of its derivatives, it produces an unspendable subsidy.\r\n       * @see {@link https://en.bitcoin.it/wiki/Genesis_block|Bitcoin Wiki}\r\n       */\r\n      this.createNewBlock(1, '0', '0');\r\n   }\r\n\r\n   /**\r\n    * Blocktron methods\r\n    */\r\n\r\n   /**\r\n    * @function createNewBlock\r\n    * Blocktron method to create a new block on to the blockchain\r\n    * @param {String} nonce - The nonce obtained from proof-of-work\r\n    * @param {String} previousHash - The hash of the previous block\r\n    * @param {String} hash - The hash generated from this block's data\r\n    * @returns {Object} - Returns the new block object\r\n    */\r\n   createNewBlock(nonce, previousHash, hash) {\r\n      /**\r\n       * Validate the parameters\r\n       */\r\n      nonce = nonce\r\n         ? nonce\r\n         : (function() {\r\n              throw new Error('Nonce required');\r\n           })();\r\n      previousHash = previousHash\r\n         ? previousHash\r\n         : (function() {\r\n              throw new Error('Previous hash required');\r\n           })();\r\n      hash = hash\r\n         ? hash\r\n         : (function() {\r\n              throw new Error('Hash required');\r\n           })();\r\n\r\n      /**\r\n       * @type {Object}\r\n       * @const newBlock - An atomic block in the chain\r\n       * @property {Number} index - The chronological position of this block in the chain\r\n       * @property {String} timeStamp - The time of creation of the block\r\n       * @property {String} transactions - The value of transaction to be recorded\r\n       * @property {String} nonce - The nonce obtained from proof-of-work\r\n       * @property {String} hash - The hash generated from this block's data\r\n       * @property {String} previousHash - The hash of the previous block\r\n       */\r\n      const newBlock = {\r\n         index: this.chain.length + 1,\r\n         timeStamp: Date.now(),\r\n         transactions: this.pendingTransactions,\r\n         nonce: nonce,\r\n         hash: hash,\r\n         previousHash: previousHash\r\n      };\r\n\r\n      /**\r\n       * Reset the pendingTransactions array back to empty after creating the new block,\r\n       * so that the createNewBlock method can start over again from zero.\r\n       */\r\n      this.pendingTransactions = [];\r\n\r\n      /**\r\n       * Then push the new block to the chain\r\n       */\r\n      this.chain.push(newBlock);\r\n\r\n      /**\r\n       * Returns the newly created block\r\n       */\r\n      return newBlock;\r\n   }\r\n\r\n   /**\r\n    * @function getLastBlock\r\n    * A method to retreive the penultimate block with respect to current block\r\n    * @returns {Object} - Returns the block object\r\n    */\r\n   getLastBlock() {\r\n      /**\r\n       * This method simply returns the block object from the data\r\n       * structure at the penultimate position\r\n       */\r\n      return this.chain[this.chain.length - 1];\r\n   }\r\n\r\n   /**\r\n    * @function createNewTransaction\r\n    * A method to create a new transaction\r\n    * @param {Number} amount - The amount/value to be recorded\r\n    * @param {String} sender - The adress of the sender\r\n    * @param {String} receiver - The address of the receiver\r\n    * @returns {Object} - Returns the transaction object\r\n    */\r\n   createNewTransaction(amount, sender, receiver) {\r\n      /**\r\n       * Validate the parameters\r\n       */\r\n      amount = amount\r\n         ? amount\r\n         : (function() {\r\n              throw new Error('Amount required');\r\n           })();\r\n      sender = sender\r\n         ? sender\r\n         : (function() {\r\n              throw new Error('Sender required');\r\n           })();\r\n      receiver = receiver\r\n         ? receiver\r\n         : (function() {\r\n              throw new Error('receiver required');\r\n           })();\r\n\r\n      /**\r\n       * @type {Object}\r\n       * @const newTransactions - An atomic transactions block in the chain\r\n       * @property {Number} amount - The value/amount to be recorded\r\n       * @property {String} sender - The adress of the sender\r\n       * @property {String} receiver - The address of the receiver\r\n       */\r\n      const newTransactions = {\r\n         amount: amount,\r\n         sender: sender,\r\n         receiver: receiver\r\n      };\r\n\r\n      /**\r\n       * Push the new transaction to the chain\r\n       */\r\n      this.pendingTransactions.push(newTransactions);\r\n\r\n      /**\r\n       * Returns the number of the block, this transaction will be added to\r\n       */\r\n      return this.getLastBlock()['index'] + 1;\r\n   }\r\n\r\n   /**\r\n    * @function hashBlock\r\n    * A helper method to generate a hash string out of a blocks data\r\n    * @param {String} previousBlockHash - The hash of the previous block\r\n    * @param {Object} currentBlockData - The current block's data\r\n    * @param {Number} nonce - The nonce of the block\r\n    * @returns {String} - The hash string generated out of the block data\r\n    */\r\n   hashBlock(previousBlockHash, currentBlockData, nonce) {\r\n      /**\r\n       * Validate the parameters\r\n       */\r\n      previousBlockHash = previousBlockHash\r\n         ? previousBlockHash\r\n         : (function() {\r\n              throw new Error('Previous block hash required');\r\n           })();\r\n      currentBlockData = currentBlockData\r\n         ? currentBlockData\r\n         : (function() {\r\n              throw new Error('Current block data required');\r\n           })();\r\n      nonce = nonce ? nonce : '';\r\n      return hasher(\r\n         previousBlockHash + nonce.toString() + JSON.stringify(currentBlockData)\r\n      );\r\n   }\r\n\r\n   /**\r\n    * @function proofOfWork\r\n    * An opinionated, standardized, and universally approved blockchain method\r\n    * to validate random blocks added to the blockchain.\r\n    * Process:\r\n    * 1. Repeatedly hash the block data until it reaches the format: '0000<HF98WDYS89DCSD>'.\r\n    * 2. Uses current block data as well as previous block hash.\r\n    * 3. Continuously change the nonce until the correct hash is obtained.\r\n    * 4. Return the nonce value which generates the correct hash.\r\n    * The proofOfWork algorithm runs to a complexity of O(n).\r\n    * @see {@link https://keepingstock.net/explaining-blockchain-how-proof-of-work-enables-trustless-consensus-2abed27f0845| Explaining blockchain}\r\n    * @param {String} previousBlockHash - The hash of the previous block\r\n    * @param {Object} currentBlockData - The current block's data\r\n    * @returns {Number} - Returns the valid nonce number\r\n    */\r\n   proofOfWork(previousBlockHash, currentBlockData) {\r\n      /**\r\n       * Use block scoping rather than constants, because there is a guarenteed rebinding of data to objects.\r\n       */\r\n      let nonce = 0;\r\n      let hashString = this.hashBlock(previousBlockHash, currentBlockData, nonce);\r\n\r\n      /**\r\n       * While-loop is prefered over for-loop or other looping constructs.\r\n       * The loop exit point is unknown in this case.\r\n       * @see {@link https://stackoverflow.com/questions/39969145/while-loops-vs-for-loops-in-javascript|While Loops vs. For Loops in JavaScript?}\r\n       */\r\n      while (hashString.substring(0, 4) !== '0000') {\r\n         nonce++;\r\n         hashString = this.hashBlock(previousBlockHash, currentBlockData, nonce);\r\n      }\r\n\r\n      /**\r\n       * Simple returns the nonce value which can generate the correct\r\n       * hash string of pre-determined format, thus the proof.\r\n       */\r\n      return nonce;\r\n   }\r\n}\r\n\r\nmodule.exports = Blocktron;\r\n","var crypto = require('crypto');\n\n// Node.js has its own Crypto function that can handle this natively\nvar sha256 = module.exports = function(message, options) {\n\tvar c = crypto.createHash('sha256');\n\t\n\tif (Buffer.isBuffer(message)) {\n\t\tc.update(message);\n\t} else if (Array.isArray(message)) {\n\t\t// Array of byte values\n\t\tc.update(new Buffer(message));\n\t} else {\n\t\t// Otherwise, treat as a binary string\n\t\tc.update(new Buffer(message, 'binary'));\n\t}\n\tvar buf = c.digest();\n\t\n\tif (options && options.asBytes) {\n\t\t// Array of bytes as decimal integers\n\t\tvar a = [];\n\t\tfor(var i = 0; i < buf.length; i++) {\n\t\t\ta.push(buf[i]);\n\t\t}\n\t\treturn a;\n\t} else if (options && options.asString) {\n\t\t// Binary string\n\t\treturn buf.toString('binary');\n\t} else {\n\t\t// String of hex characters\n\t\treturn buf.toString('hex');\n\t}\n}\n\nsha256.x2 = function(message, options) {\n\treturn sha256(sha256(message, { asBytes:true }), options)\n}\n","module.exports = require(\"crypto\");"],"sourceRoot":""}