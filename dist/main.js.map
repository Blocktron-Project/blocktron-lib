{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/index.js","webpack:///./node_modules/sha256/lib/nodecrypto.js","webpack:///external \"crypto\""],"names":["hasher","require","Blocktron","chain","pendingTransactions","createNewBlock","nonce","previousHash","hash","Error","newBlock","index","length","timeStamp","Date","now","transactions","push","amount","sender","reciever","newTransactions","getLastBlock","previousBlockHash","currentBlockData","toString","JSON","stringify","hashString","hashBlock","substring","module","exports"],"mappings":"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","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/**\r\n * blocktron-lib\r\n * This file contains the Blocktron Class which houses the core blockchain functions and methods\r\n * Written by: Sandeep Vattapparambil\r\n * Email: sandeepv68@gmail.com\r\n * Website: www.sandeepv.in\r\n */\r\n\r\n/**\r\n * Blocktron Module\r\n * @module Blocktron\r\n */\r\n\r\n/**\r\n * ECMAScript 5's strict mode is a way to opt in to a restricted variant of JavaScript,\r\n * thereby implicitly opting-out of \"sloppy mode\". Strict mode isn't just a subset:\r\n * it intentionally has different semantics from normal code. Browsers not supporting\r\n * strict mode will run strict mode code with different behavior from browsers that do,\r\n * so don't rely on strict mode without feature-testing for support for the relevant\r\n * aspects of strict mode. Strict mode code and non-strict mode code can coexist,\r\n * so scripts can opt into strict mode incrementally.\r\n * Strict mode makes several changes to normal JavaScript semantics:\r\n *  1. Eliminates some JavaScript silent errors by changing them to throw errors.\r\n *  2. Fixes mistakes that make it difficult for JavaScript engines to perform optimizations:\r\n *     strict mode code can sometimes be made to run faster than identical code that's not strict mode.\r\n *  3. Prohibits some syntax likely to be defined in future versions of ECMAScript.\r\n */\r\n'use strict';\r\n\r\n/**\r\n * A JavaScript component to compute the SHA256 of strings or bytes.\r\n * Note: when Node.js is detected, the Node Crypto component is used \r\n * instead of re-implementing the SHA256 hash logic.\r\n * @see {@link https://www.npmjs.com/package/sha256|NPM sha256}\r\n * @see {@link https://en.wikipedia.org/wiki/SHA-2|SHA-2}\r\n */\r\nconst hasher = require('sha256');\r\n\r\n/**\r\n * The main Blocktron Class.\r\n * @class Blocktron\r\n */\r\nclass Blocktron {\r\n  /**\r\n   * The Blocktron Class properties constructor\r\n   */\r\n  constructor() {\r\n    this.chain = [];\r\n    this.pendingTransactions = [];\r\n    /**\r\n     * Genesis block defaults\r\n     * A genesis block is the first block of a block chain. Modern versions of Bitcoin number \r\n     * it as block 0, though very early versions counted it as block 1. The genesis block is \r\n     * almost always hardcoded into the software of the applications that utilize its block \r\n     * chain. It is a special case in that it does not reference a previous block, and for Bitcoin \r\n     * and almost all of its derivatives, it produces an unspendable subsidy.\r\n     * @see {@link https://en.bitcoin.it/wiki/Genesis_block|Bitcoin Wiki}\r\n     */\r\n    this.createNewBlock(1, '0', '0');\r\n  }\r\n\r\n  /**\r\n   * Blocktron methods\r\n   */\r\n\r\n  /**\r\n   * @function createNewBlock\r\n   * Blocktron method to create a new block on to the blockchain\r\n   * @param {String} nonce - The nonce obtained from proof-of-work\r\n   * @param {String} previousHash - The hash of the previous block\r\n   * @param {String} hash - The hash generated from this block's data\r\n   * @returns {Object} - Returns the new block object\r\n   */\r\n  createNewBlock(nonce, previousHash, hash) {\r\n    /**\r\n     * Validate the parameters\r\n     */\r\n    nonce = nonce ? nonce : (function () {\r\n      throw new Error('Nonce required');\r\n    })();\r\n    previousHash = previousHash ? previousHash : (function () {\r\n      throw new Error('Previous hash required');\r\n    })();\r\n    hash = hash ? hash : (function () {\r\n      throw new Error('Hash required');\r\n    })();\r\n\r\n    /**\r\n     * @type {Object}\r\n     * @const newBlock - An atomic block in the chain\r\n     * @property {Number} index - The chronological position of this block in the chain\r\n     * @property {String} timeStamp - The time of creation of the block\r\n     * @property {String} transactions - The value of transaction to be recorded\r\n     * @property {String} nonce - The nonce obtained from proof-of-work\r\n     * @property {String} hash - The hash generated from this block's data\r\n     * @property {String} previousHash - The hash of the previous block\r\n     */\r\n    const newBlock = {\r\n      index: this.chain.length + 1,\r\n      timeStamp: Date.now(),\r\n      transactions: this.pendingTransactions,\r\n      nonce: nonce,\r\n      hash: hash,\r\n      previousHash: previousHash\r\n    };\r\n\r\n    /**\r\n     * Reset the pendingTransactions array back to empty after creating the new block,\r\n     * so that the createNewBlock method can start over again from zero.\r\n     */\r\n    this.pendingTransactions = [];\r\n\r\n    /**\r\n     * Then push the new block to the chain\r\n     */\r\n    this.chain.push(newBlock);\r\n\r\n    /**\r\n     * Returns the newly created block\r\n     */\r\n    return newBlock;\r\n  };\r\n\r\n  /**\r\n   * @function getLastBlock\r\n   * A method to retreive the penultimate block with respect to current block\r\n   * @returns {Object} - Returns the block object\r\n   */\r\n  getLastBlock() {\r\n    /**\r\n     * This method simply returns the block object from the data \r\n     * structure at the penultimate position\r\n     */\r\n    return this.chain[this.chain.length - 1];\r\n  };\r\n\r\n  /**\r\n   * @function createNewTransaction\r\n   * A method to create a new transaction\r\n   * @param {Number} amount - The amount/value to be recorded\r\n   * @param {String} sender - The adress of the sender\r\n   * @param {String} reciever - The address of the reciever\r\n   * @returns {Object} - Returns the transaction object\r\n   */\r\n  createNewTransaction(amount, sender, reciever) {\r\n\r\n    /**\r\n     * Validate the parameters\r\n     */\r\n    amount = amount ? amount : (function () {\r\n      throw new Error('Amount required');\r\n    })();\r\n    sender = sender ? sender : (function () {\r\n      throw new Error('Sender required');\r\n    })();\r\n    reciever = reciever ? reciever : (function () {\r\n      throw new Error('Reciever required');\r\n    })();\r\n\r\n    /**\r\n     * @type {Object}\r\n     * @const newTransactions - An atomic transactions block in the chain\r\n     * @property {Number} amount - The value/amount to be recorded\r\n     * @property {String} sender - The adress of the sender\r\n     * @property {String} reciever - The address of the reciever\r\n     */\r\n    const newTransactions = {\r\n      amount: amount,\r\n      sender: sender,\r\n      reciever: reciever\r\n    };\r\n\r\n    /**\r\n     * Push the new transaction to the chain\r\n     */\r\n    this.pendingTransactions.push(newTransactions);\r\n\r\n    /**\r\n     * Returns the number of the block, this transaction will be added to\r\n     */\r\n    return this.getLastBlock()['index'] + 1;\r\n  };\r\n\r\n  /**\r\n   * @function hashBlock\r\n   * A helper method to generate a hash string out of a blocks data\r\n   * @param {String} previousBlockHash - The hash of the previous block\r\n   * @param {Object} currentBlockData - The current block's data\r\n   * @param {Number} nonce - The nonce of the block\r\n   * @returns {String} - The hash string generated out of the block data\r\n   */\r\n  hashBlock(previousBlockHash, currentBlockData, nonce) {\r\n\r\n    /**\r\n     * Validate the parameters\r\n     */\r\n    previousBlockHash = previousBlockHash ? previousBlockHash : (function () {\r\n      throw new Error('Previous block hash required');\r\n    })();\r\n    currentBlockData = currentBlockData ? currentBlockData : (function () {\r\n      throw new Error('Current block data required');\r\n    })();\r\n    nonce = nonce ? nonce : '';\r\n    return hasher(previousBlockHash + nonce.toString() + JSON.stringify(currentBlockData));\r\n  };\r\n\r\n  /**\r\n   * @function proofOfWork\r\n   * An opinionated, standardized, and universally approved blockchain method \r\n   * to validate random blocks added to the blockchain.\r\n   * Process: \r\n   * 1. Repeatedly hash the block data until it reaches the format: '0000<HF98WDYS89DCSD>'.\r\n   * 2. Uses current block data as well as previous block hash.\r\n   * 3. Continuously change the nonce until the correct hash is obtained.\r\n   * 4. Return the nonce value which generates the correct hash.\r\n   * The entire proofOfWork calculation runs to a time complexity of O(n).\r\n   * @see {@link https://keepingstock.net/explaining-blockchain-how-proof-of-work-enables-trustless-consensus-2abed27f0845| Explaining blockchain}\r\n   * @param {String} previousBlockHash - The hash of the previous block\r\n   * @param {Object} currentBlockData - The current block's data\r\n   * @returns {Number} - Returns the valid nonce number\r\n   */\r\n  proofOfWork(previousBlockHash, currentBlockData) {\r\n\r\n    /**\r\n     * Use block scoping rather than constants, because there is a guarenteed rebinding of data to objects.\r\n     */\r\n    let nonce = 0;\r\n    let hashString = this.hashBlock(previousBlockHash, currentBlockData, nonce);\r\n\r\n    /**\r\n     * While-loop is prefered over for-loop or other looping constructs.\r\n     * The loop exit point is unknown in this case.\r\n     * @see {@link https://stackoverflow.com/questions/39969145/while-loops-vs-for-loops-in-javascript|While Loops vs. For Loops in JavaScript?}\r\n     */\r\n    while (hashString.substring(0, 4) !== '0000') {\r\n      nonce++;\r\n      hashString = this.hashBlock(previousBlockHash, currentBlockData, nonce);\r\n    }\r\n\r\n    /**\r\n     * Simple returns the nonce value which can generate the correct \r\n     * hash string of pre-determined format, thus the proof.\r\n     */\r\n    return nonce;\r\n  };\r\n}\r\n\r\nmodule.exports = Blocktron;\r\n","var crypto = require('crypto');\n\n// Node.js has its own Crypto function that can handle this natively\nvar sha256 = module.exports = function(message, options) {\n\tvar c = crypto.createHash('sha256');\n\t\n\tif (Buffer.isBuffer(message)) {\n\t\tc.update(message);\n\t} else if (Array.isArray(message)) {\n\t\t// Array of byte values\n\t\tc.update(new Buffer(message));\n\t} else {\n\t\t// Otherwise, treat as a binary string\n\t\tc.update(new Buffer(message, 'binary'));\n\t}\n\tvar buf = c.digest();\n\t\n\tif (options && options.asBytes) {\n\t\t// Array of bytes as decimal integers\n\t\tvar a = [];\n\t\tfor(var i = 0; i < buf.length; i++) {\n\t\t\ta.push(buf[i]);\n\t\t}\n\t\treturn a;\n\t} else if (options && options.asString) {\n\t\t// Binary string\n\t\treturn buf.toString('binary');\n\t} else {\n\t\t// String of hex characters\n\t\treturn buf.toString('hex');\n\t}\n}\n\nsha256.x2 = function(message, options) {\n\treturn sha256(sha256(message, { asBytes:true }), options)\n}\n","module.exports = require(\"crypto\");"],"sourceRoot":""}